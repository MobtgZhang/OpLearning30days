# 第02天：汇编语言学习与Makefile入门
## 主要术语

### 8086CPU寄存器
以下是16位的寄存器
+ AX,累加寄存器
+ BX,基址寄存器
+ CX,计数寄存器
+ DX,数据寄存器
+ SP,栈指针寄存器
+ BP,基地寄存器
+ SI,源变址寄存器
+ DI,目的变址寄存器

对于AX,BX,CX,DX寄存器，存在一个高位和低位寄存器，分别叫做AL,AH,BL,BH,CL,CH,DL,DH寄存器，位数大小为8位

以下是16位的段寄存器
+ ES,附加段寄存器
+ CS,代码段寄存器
+ SS,栈段寄存器
+ DS,数据段寄存器

以下是标志位寄存器
+ EFLAGS标志位寄存器

### 8086七种寻址方式

8086CPU一般有七种寻址方式：立即寻址，寄存器寻址，直接寻址，寄存器简介寻址，寄存器相对寻址，基址变址寻址，相对基址变址寻址。特别是后面五中寻址方式术语存储器寻址方式，用于说明操作数或者操作数地址所在存储单元的地址。

+ 立即寻址，通过立即数寻址方式寻址，寻址速度最快；
```assembly
;这里是立即数寻址方式寻址
mov ax,1234h
```
+ 寄存器寻址，这种寻址方式中，操作数在CPU的寄存器中，在指令当中制定寄存器即可；
```assembly
;将dx的高位dh保存到ax低位al
mov al,dh
```
+ 直接寻址，这种寻址方式，指令直接包含有操作数的有效地址。操作数一般存放在数据段，所以操作数的地址由DS加上指令中给出的16位偏移地址得到。

举个例子，假设DS寄存器当中的内容是5000H，地址为51234H存储单元当中的内容是6789H，访问此地址如下所示
```assembly
mov ax,[1234H]
```
当然也可以使用其他的段寄存器。这种寻址方式常用语处理单个存储器变量的情形。由于为16位CPU，所以可访问的最大内存地址为2^16bit=64KB，直接存执的操作数通常是程序当中使用的变量。

+ 寄存器间接寻址
寄存器间接寻址的操作数在存储器中，操作数有效地址在SI、DI、BX、BP这四个寄存器当中之一。一般地，若有效地址在SI、DI和BX当中，则以DS段寄存器的内容为段值；若有效地址在BP当中，则以SS段寄存器的内容为段值。

举个例子，
```assembly
;自动引用DS作为段寄存器
mov ax,[di]
;引用CS段寄存器
mov dl,cs:[bx]
;引用SS段寄存器
mov [bp],cx
```
+ 寄存器相对寻址，操作数在存储器当中，操作数的有效地址是一个基址寄存器（bx,bp）或者变址寄存器的（si,di）内容加上指令中给定的位移量之和，位移量是16位或者8位。
```assembly
;引用DS寄存器，若(di)=1245h,则寻址ds段寄存器地址为1245h+1223h=2468h
;引用的值为2468h地址当中的数值。
mov ax,[di+1223h]
;引用ss段寄存器
mov bx,[bp-4]
;当然也可以自行指定段寄存器，引用es段寄存器
mov ES:[BX+5],al
```
特别地，这种寻址方式同样可以使用表格处理的方式，表格的首地址可以设置为指令当中的位移量，使用修改基址或者变址寄存器的内容来存取表格当中的项值。
+ 基址变址寻址，即操作数在存储器当中，操作数的有效地址由基址寄存器之一的内容与变址寄存器之一的内容相加得到。一般地，若BP的内哦荣作为有效地址的一部分，则以ss段寄存器内容作为段值，否则以ds的内容作为段值。

当所得到的内容的有效地址超过`FFFFFH`时候，则取64K的模。
```assembly
;此时引用ds段寄存器
mov ax,[bx+di]
;增加段超越前缀指定段寄存器
mov ax,es:[bx+si]
mov ds:[bp+si],al
;以下的两种方式等价
mov ax,[bx+di]
mov ax,[bx][di]
```
这种寻址方式适用于数组或者表格处理方式，基址寄存器存放数组首地址，使用变址寄存器来定位数组当中的各元素。

+ 相对基址变址寻址，操作数在存储器中，操作数的有效地址由基址寄存器之一的内容以及指令当中给定的8位或者16位位移量相加得到。
```assembly
;自动引用ds作为段寄存器
mov ax,[bx+di-2]
;以下的四种方法是等价写法
mov ax,[bx+di+1234h]
mov ax,1234h[bx+di]
mov ax,1234h[bx][di]
mov ax,1234h[di][bx]
```
### 8086汇编语言中保留字长
+ BYTE：将立即数或者其他值解释成为8位，字节
+ WORD：将立即数或者其他值解释成为16位，字
+ DWORD：将立即数或者其他值解释成为32位，双字

### 8086汇编语言当中的跳转指令
汇编语言当中跳转指令的原理是修改cs:ip或者ip的值，一般使用以下的格式进行跳转处理

| 指令 标号

跳转方式分为以下的几种类型：段内跳转、段间跳转（短转移方式：-128到127，近转移：-32768到32767）

跳转指令有以下的分类：
1. 无条件跳转`jmp`，包括有段间、段内短转移和段内近转移；
2. 条件跳转`jcxz`，短转移；
3. 循环指令loop，短转移；
4. 过程调用/返回（call/ret）;
5. 中断指令（int）等。

操作符`offset`，使用以下的格式可以将某处的偏移地址放入bx寄存器当中
```assembly
assume cs:code
code segment
start:
    mov ax,1e33h
s_label:
    mov bx,1234h
    ;这里相当于将s_label处的偏移地址放入bx中
    mov bx,offset s_label
code ends
end start
```
#### jmp无条件转移
```assembly
;短转移
jmp short s_label
;近转移
jmp near ptr s_label
```
以上两条汇编指令，在机器指令当中保存的操作数不是目的地址，而是目的地址于当前位置的下一个地址的差，也就是在CPU当中执行jmp指令的时候不需要目的地址，只需要位置差即可
```assembly
;段间转移
jmp far ptr s_label
;寄存器跳转，注意这里是16位地址
jmp ax
;从内存单元地址中获取目标偏移地址
jmp word ptr 内存地址单元
;从内存单元地址中获取目标段地址与偏移
jmp dword ptr 内存地址单元
```
#### jcxz指令，条件转移
通过修改标志位来控制跳转，在机器指令中保存的操作数为目的地址与当前位置的下一个地址的差，判断CX=0，则跳转

#### loop指令
```assembly
loop s_label
```
当`(cx)==0`时候进行转移，每次循环完毕计数器`cx`自减1，然后进行判断处理。
### 过程调用/返回以及中断指令
过程调用以及CPU处理硬件中断时候，涉及到了程序执行指令的跳转，分别对应了过程调用/返回指令、中断指令。
## 编写Makefile文件并运行
生成对应的文件
```bash
# 生成对应的启动文件img
make boot
# 生成fat12格式下的启动文件
make fat12
# 挂载对应的文件
make loop
# 运行对应的操作系统
make run
# 删除生成的文件
make clean
```


